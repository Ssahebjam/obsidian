how the performance of algorithm scales as the size of the input grows, think of it like how bad it could take when your data gets huge

O -> stands for order of

linear => O(n)
logarithmic => o(log n)

if you are looking for a person in your notebook if you find it first time 

Your Big O notation => O(1)
- O(log<sub>2</sub> n) -> long time -> binary search
- O(n) -> linear time -> simple search
- O(n * log<sub>2</sub> n) -> fast sorting -> quick sort
- O(n<sup>2</sup>) -> slow sorting = you want to sort a list you check the list items then make a new list and sort the items in the new list by the order you want checking the first list is O(n) and adding them to the new list is O(n<sup>2</sup>) -> selection sort
- O(!n) -> n factorial-> traveling sales person
each opration is --> 0.1 second